#!/usr/bin/env bash

POTATO=2

# Path to this file
export POTATO_CORE

declare -A POTATO_INFO

function __load() {

	POTATO_CORE=$BASH_SOURCE

	POTATO_DEFAULT_ID="default"
	POTATO_DEFAULT_TASK="__main"
	POTATO_TASK_PATH_PATTERN="___TASK__"

	potato_declare POTATO_DEBUG ""
	potato_declare POTATO_DEBUG_VERBOSE ""
}

# Load an app by name or path
# Usecase:
#   potato_load_app		# Run from within the executable
#		potato_load_app /path/to/executable
#											# Load an app from within another script
#		potato_load_app app_name
#											# Re-load the app by name; required when dealing with
#											# multiple apps in the same shell
function potato_load_app() {
	unset POTATO_APP_NAME
	if [ -z "$1" ]; then
		potato_load_app_by_path $(dirname $(whereis_realpath "$0"))
	elif [ -d $1 ]; then
		potato_load_app_by_path $(realpath $1)
	elif [ $(potato_app_is_loaded $1) ]; then
		potato_load_app_by_name $1
	else
		potato_debug 'failed at loading '$1
		_throw 1000 'failed at loading '$1
	fi
}

# Load or re-load the app by its path
function potato_load_app_by_path() {
	POTATO_ROOT=$1
	_potato_load_app
	potato_declare POTATO_APP_NAME $(basename $POTATO_ROOT)
	POTATO_INFO["${POTATO_APP_NAME}_root"]=$POTATO_ROOT
}
# Re-load the app (this time by name)
function potato_load_app_by_name() {
	local app_name=$1
	POTATO_ROOT=${POTATO_INFO["${app_name}_root"]}
	_potato_load_app
	POTATO_APP_NAME=$app_name
}

function _potato_load_app() {
	[ -e $POTATO_ROOT'/.potatorc' ] && . $POTATO_ROOT'/.potatorc'
	POTATO_THIS_ID=$POTATO_DEFAULT_ID
	POTATO_THIS_TASK="$POTATO_DEFAULT_TASK"
	POTATO_THIS_ARGS=()
}

function potato_app_is_loaded() {
	local app_name=$1
	[ ${POTATO_INFO[${app_name}_root]+'EXISTS'} ] && echo 1
}

function potato_include() {
	local path=$POTATO_ROOT'/'$1
	[ -f "$path" ] && . $path
}

# TO be used with $ bash -x cmd instead of $ cmd
function potato_console_log() {
	local comment='value for '$1' is '${!1}
}
function potato_comment() {
	local comment="${@}"
}

function potato_declare() {
	local var_name=$1
	local default
	[ -z "$2" ] && default="" || default="$2"
	[ -z "${!var_name}" ] && printf -v "$var_name" '%s' "$default"
}

function potato_debug() {
	local __line_number=$BASH_LINENO
 	local __func_name=${FUNCNAME[1]}
 	local __source=$(basename ${BASH_SOURCE[1]})
	local prefix="[DEBUG $__func_name() in $__source:$__line_number] "
	local message
	[ -z "$1" ] && message="$prefix" || message="$prefix$1"
	[ $POTATO_DEBUG ] && echo $message
	[ $POTATO_DEBUG_VERBOSE ] &&
		echo "called from ${FUNCNAME[@]:1}"
}

function potato_process_input_args() {
	if [ -f $(potato_task_path $1) ]; then
		potato_comment 'task identified as '$1
		POTATO_THIS_TASK="$1"
		POTATO_THIS_ARGS=("${@:2}")
	elif [ "$#" -gt "1" ] && [ -f $(potato_task_path $2) ]; then
		potato_comment 'id was detected. task identified as '$2
		POTATO_THIS_ID=$1
		POTATO_THIS_TASK=$2
		POTATO_THIS_ARGS=("${@:3}")
	else
		potato_comment 'none. task remains as '$POTATO_THIS_TASK
		POTATO_THIS_ARGS=("${@:1}")
	fi
}

function potato_task_path() {
	local task=$1
	local path=$(sed "s/__TASK__/$task/gI;s/__APP__/$POTATO_APP_NAME/gI" <<< $POTATO_TASK_PATH_PATTERN)
	echo "$POTATO_ROOT/$path"
}

function potato_app_get_tasks() {
	local app_name=$1
	potato_load_app_by_name $app_name
	local root=$(potato_app_get_root $app_name)
	local pattern=$(sed "s/__TASK__/*/gI;s/__APP__/$POTATO_APP_NAME/gI" <<< $POTATO_TASK_PATH_PATTERN)
	local regexp=$(sed "s/__TASK__/\(\.\*\)/gI;s/__APP__/$POTATO_APP_NAME/gI" <<< $POTATO_TASK_PATH_PATTERN)
	for f in $(find $root -path "*$pattern" -printf '%P\n' -type f); do
		[[ $f =~ $regexp ]] && echo ${BASH_REMATCH[1]}
	done
}

function print_r() {
	local array_name=$1
	# Copyright https://stackoverflow.com/a/1612144
	# Copyright https://unix.stackexchange.com/a/366621
	typeset -p $array_name | sed s/^.*\(// | tr -d ")\'\""  | tr "[" "\n" | sed s/]=/'='/ | grep -v -e '^$'
}

function potato_app_get_root() {
	local app_name=$1
	echo ${POTATO_INFO["${app_name}_root"]}
}

function potato_get_id() {
	echo $POTATO_THIS_ID
}

function potato_get_task() {
	echo $POTATO_THIS_TASK
}

function potato_get_arg() {
	local index=$1
	echo ${POTATO_THIS_ARGS[$index -1]}
}

function potato_get_args() {
	echo "${POTATO_THIS_ARGS[@]}"
}

function potato_test_args() {
	echo "ID: 	"$(potato_get_id)
	echo "TASK:	"$(potato_get_task)
	echo "ARG[1]:	"$(potato_get_arg 1)
	echo "ARG[2]:	"$(potato_get_arg 2)
}

function potato_load_task() {
	local path=$(potato_task_path $1)
	[ ! -f $path ] && potato_debug "Failed to load $path" && return 0
	POTATO_SKIP_LOAD=1 . $BASH_SOURCE	# unsets functions set by previousely loaded task
	. $path
}

function potato_run_task() {
	potato_load_task $1
	run
}

function potato_exec() {
	potato_process_input_args "${@}"
	potato_load_task $(potato_get_task)
	run
}

function run() {
	potato_debug 'ERROR You need to implement run() in '$(potato_task_path $(potato_get_task))
}

function potato_input() {
	local message;
	[ -z "$1" ] && message="" || message="$1"
	local default;
  [ -z "$2" ] && default="" || default="$2"
	read -p "$message" value
	[ -z "$value" ] && value=$default
	echo $value
}

function _try {
	unset POTATO_EXCEPTION_MESSAGE
	$1 ${@:2}
}
function _catch() {
	[ ! -z "$POTATO_EXCEPTION_MESSAGE" ] && printf -v "$1" '%s' "$POTATO_EXCEPTION_MESSAGE" && return
}
function _throw() {
	POTATO_EXCEPTION_ERRNO=$1
	POTATO_EXCEPTION_MESSAGE=$2
}
function potato_setup_autocomplete() {
	local app_loader=$1
	_try potato_load_app $1
	_catch E && {
		echo "Exception: $E!"
	}
	potato_app_setup_autocomplete $POTATO_APP_NAME
}

function potato_app_setup_autocomplete() {
	local app_name=$1
	complete -o nospace -F _potato_setup_autocomplete $app_name
}

# Copyright https://askubuntu.com/a/483149
_potato_setup_autocomplete()
{
	local app_name=$1
	local last_arg=$2

  COMPREPLY=()
	if [ "${#COMP_WORDS[@]}" -eq 2 ]; then
		local list=$(potato_app_get_tasks $app_name)
	  COMPREPLY=( $(compgen -W "$list" -- ${COMP_WORDS[COMP_CWORD]}) )
	elif [ "${#COMP_WORDS[@]}" -eq 3 ]; then
		local task=${COMP_WORDS[1]}
		potato_load_app_by_name $app_name
		potato_load_task $task
		local list=$(__autocomplete)
		COMPREPLY=( $(compgen -W "$list" -- ${COMP_WORDS[COMP_CWORD]}) )
	fi
  return 0
}
function __autocomplete() {
	potato_comment "provide this function to allow autocompletion for arguments."
}
function __help() {
	potato_debug "provide this function in the task to enable task-specific help."
}

# Copyright http://stackoverflow.com/a/7400673/257479
myreadlink() { [ ! -h "$1" ] && echo "$1" || (local link="$(expr "$(command ls -ld -- "$1")" : '.*-> \(.*\)$')"; cd $(dirname $1); myreadlink "$link" | sed "s|^\([^/].*\)\$|$(dirname $1)/\1|"); }
whereis() { echo $1 | sed "s|^\([^/].*/.*\)|$(pwd)/\1|;s|^\([^/]*\)$|$(which -- $1)|;s|^$|$1|"; }
whereis_realpath() { local SCRIPT_PATH=$(whereis $1); myreadlink ${SCRIPT_PATH} | sed "s|^\([^/].*\)\$|$(dirname ${SCRIPT_PATH})/\1|"; }

[ -z "$POTATO_SKIP_LOAD" ] && __load "${@}"
